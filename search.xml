<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>建造者模式之儿童餐</title>
    <url>/2020/11/17/design-pattern02/</url>
    <content><![CDATA[<h1 id="建造者模式之儿童餐"><a href="#建造者模式之儿童餐" class="headerlink" title="建造者模式之儿童餐"></a>建造者模式之儿童餐</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong> 一些基本部件不会变，而其组合经常变化的时候。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 将变与不变分离开。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong> 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
</blockquote>
<blockquote>
<p>**优点： ** 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
</blockquote>
<blockquote>
<p><strong>注意事项：</strong> 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>建造者模式可以用于快餐店制作儿童餐。 典型的儿童餐包括一个主食、一个辅食一杯饮料和一个玩具(例如汉堡、炸鸡、可乐和玩具车)。这些在不同的儿童餐中可以是不同的,但是组合成儿童餐的过程是相同的。 无论顾客点的是汉堡、三明治还是鸡肉,过程都是一样的。 柜台的员工直接把主食、辅食和玩具放在一起。 这些是放在一个袋子中的。 饮料被倒入杯中,放在袋子外边。 这些过程在相互竞争的餐馆中是同样的。</p>
</blockquote>
<h2 id="实例类图"><a href="#实例类图" class="headerlink" title="实例类图"></a>实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117174059572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="实例实现代码"><a href="#实例实现代码" class="headerlink" title="实例实现代码"></a>实例实现代码</h2><blockquote>
<p>3.1产品类ZC32Meal(套餐类)</p>
</blockquote>
<pre><code>public class ZC32Meal {
//food1、food2、toy和drink是部件
private String food1;
private String food2;
private String drink;
private String toy;

public String getFood1() {
    return food1;
}
public void setFood1(String food1) {
    this.food1 = food1;
}
public String getFood2() {
    return food2;
}
public void setFood2(String food2) {
    this.food2 = food2;
}
public String getDrink() {
    return drink;
}
public void setDrink(String drink) {
    this.drink = drink;
}
public String getToy() {
    return toy;
}
public void setToy(String toy) {
    this.toy = toy;
}
}
</code></pre>
<blockquote>
<p>3.2抽象建造者类ZC32MealBuilder(套餐建造者类)</p>
</blockquote>
<pre><code>public abstract class ZC32MealBuilder {
protected ZC32Meal meal =new ZC32Meal();

public abstract void buildFood1();
public abstract void buildFood2();
public abstract void buildDrink();
public abstract void buildToy();

public ZC32Meal getMeal()
    {
    return meal;
    }
}
</code></pre>
<blockquote>
<p>3.31具体建造者类ZC32SubMealBuilderA(套餐建造者A类)</p>
</blockquote>
<pre><code>public class ZC32SubMealBuilderA extends ZC32MealBuilder{
    public void buildFood1()
    {
        meal.setFood1("一个鸡腿堡");
    }
    public void buildFood2()
    {
        meal.setFood2("一个汉堡");
    }
    public void buildDrink()
    {
        meal.setDrink("一杯牛奶");
    }
    public void buildToy()
    {
        meal.setToy("一个玩具娃娃");
    }
 
}
</code></pre>
<blockquote>
<p>3.32具体建造者类ZC32SubMealBuilderA(套餐建造者B类)</p>
</blockquote>
<pre><code>public class ZC32SubMealBuilderB extends ZC32MealBuilder{
    public void buildFood1()
    {
        meal.setFood1("一个披萨");
    }
    public void buildFood2()
    {
        meal.setFood2("一个苹果");
    }
    public void buildDrink()
    {
        meal.setDrink("一杯可乐");
    }
    public void buildToy()
    {
        meal.setToy("一个变形金刚玩具");
    }
}
</code></pre>
<blockquote>
<p>3.4指挥者类ZC32Waiter(服务员类)</p>
</blockquote>
<pre><code>    public class ZC32Waiter {
        private ZC32MealBuilder mb;
     
        public void setMealBuilder(ZC32MealBuilder mb) {
            this.mb = mb;
        }
        
        public ZC32Meal construct()
        {
            mb.buildFood1();
            mb.buildFood2();
            mb.buildDrink();
            mb.buildToy();
            return mb.getMeal();
        }
    }
</code></pre>
<blockquote>
<p>3.5客户端测试类ZC32Client</p>
</blockquote>
<pre><code>public class ZC32Client {
    public static void main (String args[]) {
    //动态确定套餐种类
    ZC32MealBuilder mb=(ZC32MealBuilder)XMLUtil.getBean();
    //服务员是指挥者
    ZC32Waiter zc32waiter=new ZC32Waiter();
    //服务员准备套餐
    zc32waiter.setMealBuilder(mb);
    //客户获得套餐
    ZC32Meal meal=zc32waiter.construct();
    
    System.out.println("套餐组成：");
    System.out.println(meal.getFood1());
    System.out.println(meal.getFood2());
    System.out.println(meal.getDrink());
    System.out.println(meal.getToy());
}
}
</code></pre>
<h2 id="4、辅助代码"><a href="#4、辅助代码" class="headerlink" title="4、辅助代码"></a>4、辅助代码</h2><blockquote>
<p>4.1XML操作工具类XMLUtil</p>
</blockquote>
<pre><code>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
 
public class XMLUtil {
    public static Object getBean() {
        try {
            //创建DOM文档对象
            DocumentBuilderFactory dFactory =DocumentBuilderFactory.newInstance();
            DocumentBuilder builder =dFactory.newDocumentBuilder();
            Document doc;
            doc=builder.parse(new File("config.xml"));
            
            NodeList nl=doc.getElementsByTagName("className");
            Node classNode=nl.item(0).getFirstChild();
            String cName=classNode.getNodeValue();
            
            Class c=Class.forName(cName);
            Object obj=c.newInstance();
            return obj;
        }
        catch(Exception e)
        {
            e.printStackTrace();
            return null;
        }
    }
}
</code></pre>
<blockquote>
<p>4.2配置文件config.xml</p>
</blockquote>
<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;config&gt;
        &lt;className&gt;ZC32SubMealBuilderB&lt;/className&gt;
    &lt;/config&gt;
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p>通过修改配置文件config.xml可得到不同的结果<br>  5.1套餐A<br>  <img src="https://img-blog.csdnimg.cn/20201117182550295.png"></p>
</blockquote>
<blockquote>
<p>5.2套餐B<br><img src="https://img-blog.csdnimg.cn/20201117182853140.png"><br><img src="https://img-blog.csdnimg.cn/20201117182931576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>用工厂方法模式实现四则计算器</title>
    <url>/2020/11/17/design-pattern01/</url>
    <content><![CDATA[<h1 id="用工厂方法模式实现四则计算器"><a href="#用工厂方法模式实现四则计算器" class="headerlink" title="用工厂方法模式实现四则计算器"></a>用工厂方法模式实现四则计算器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>创建过程在其子类执行。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>
</blockquote>
<blockquote>
<p>**优点： **1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
</blockquote>
<blockquote>
<p>**使用场景： **1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
</blockquote>
<blockquote>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
</blockquote>
<h2 id="结构类图"><a href="#结构类图" class="headerlink" title="结构类图"></a>结构类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117172340744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="实例实现代码"><a href="#实例实现代码" class="headerlink" title="实例实现代码"></a>实例实现代码</h2><blockquote>
<p>步骤1： 创建抽象工厂类 zc32OperationFactory，定义具体工厂的公共接口</p>
</blockquote>
<pre><code>interface OperationFactory { // 工厂接口
    public static Operation getResult(String operator) {
        Operation oper=null;
        switch(operator) {
            case"+":
                oper=new AddOperation();
                break;
            case"-":
                oper=new SubOperation();
                break;
            case"*":
                oper=new ChengOperation();
                break;
            case"/":
                oper=new ChuOperation();
                break;
        }
        return oper;
    }
}
</code></pre>
<blockquote>
<p>步骤2： 创建抽象产品类zc32Operation  ，定义具体产品的公共接口；</p>
</blockquote>
<pre><code>public class Operation {
    public double num1;
    public double num2;
    public double getNum1() {
        return num1;
    }
    public void setNum1(double num1) {
        this.num1 = num1;
    }
    public double getNum2() {
        return num2;
    }
    public void setNum2(double num2) {
        this.num2 = num2;
    }
 
    public  double getResult() {
        double result=0;
        return result;
    }
 
}
</code></pre>
<blockquote>
<p>步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；</p>
</blockquote>
<p><strong>3.1具体运算类zc32AddOperation(加法类)</strong></p>
<pre><code>    //加法类
    public class AddOperation extends Operation{
        public double getResult() {
            double result=0;
            result=(num1+num2);
            return result;
        }
    }
</code></pre>
<p><strong>3.2具体运算类zc32SubOperation(减法类)</strong></p>
<pre><code>    //减法类
    public class SubOperation  extends Operation{
        public double getResult() {
            double result=0;
            result=(num1-num2);
            return result;
    }}
</code></pre>
<p><strong>3.3具体运算类zc32ChengOperation(乘法类)</strong></p>
<pre><code>    //乘法类
    public class ChengOperation extends Operation{
        public double getResult() {
            double result=0;
            result=(num1*num2);
            return result;
        }}
</code></pre>
<p><strong>3.4具体运算类zc32ChuOperation(除法类)</strong></p>
<pre><code>    //除法类
    public class ChuOperation extends Operation{
        public double getResult() {
            double result=0;
            result=(num1/num2);
            return result;
     
    }}
</code></pre>
<blockquote>
<p>步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</p>
</blockquote>
<p><strong>4.1具体工厂类zc32OAddFactory（加法类）</strong></p>
<pre><code>    public class AddFactory implements OperationFactory { // 表示加法类工厂     
            public Operation createOperation() {
                return new AddOperation();
            }
     
    }
</code></pre>
<p><strong>4.2具体工厂类zc32SubFactory（减法类）</strong></p>
<pre><code>    public class SubFactory implements OperationFactory { // 表示减法类工厂     
            public Operation createOperation() {
                return new SubOperation();
            }
    }
</code></pre>
<p><strong>4.3具体工厂类zc32ChengFactory（乘法类）</strong></p>
<pre><code>    public class ChengFactory implements OperationFactory { // 表示乘法类工厂     
            public Operation createOperation() {     
                return new ChengOperation();
            }
    }
</code></pre>
<p><strong>4.4具体工厂类zc32ChuFactor（除法类）</strong></p>
<pre><code>    public class ChuFactory  implements OperationFactory { // 表示除法类工厂     
            public Operation createOperation() {     
                return new ChuOperation();
            }}
</code></pre>
<blockquote>
<p>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</p>
</blockquote>
<p><strong>5.1客户端类ZC32Client</strong></p>
<pre><code>import java.util.Scanner;
 
public class ZC32Client{
    public static void main(String[] args) {
        double result = 0;
        //1.接收控制台输入
                System.out.println("-----计算器程序-----");
                System.out.println("输入第一个操作数");
                Scanner scan = new Scanner(System.in);
                String strNum1 = scan.nextLine();
                
                System.out.println("输入运算符");
                String operation = scan.nextLine();
                
                System.out.println("输入第二个操作数");
                String strNum2 = scan.nextLine();
                double num1 = Double.parseDouble(strNum1);
                double num2 = Double.parseDouble(strNum2);
        
        Operation oper=OperationFactory.getResult(operation);
        oper.setNum1(num1);
        oper.setNum2(num2);
        result=oper.getResult();
        System.out.println(num1 + operation + num2 + "=" + result);
    }
 
}
</code></pre>
<p><strong>结果：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117172013225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式之手机主题</title>
    <url>/2020/11/18/design-pattern03/</url>
    <content><![CDATA[<h1 id="抽象工厂模式之手机主题"><a href="#抽象工厂模式之手机主题" class="headerlink" title="抽象工厂模式之手机主题"></a>抽象工厂模式之手机主题</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 主要解决接口选择的问题。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong> 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 在一个产品族里面，定义多个产品。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong> 在一个工厂里聚合多个同类产品。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
</blockquote>
<blockquote>
<p>**优点： ** 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong> 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
</blockquote>
<blockquote>
<p><strong>注意事项：</strong> 产品族难扩展，产品等级易扩展。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>某手机操作系统可以根据用户不同的喜好在2种主题之间进行切换，随着主题的变化，系统中的字体、app图标、壁纸、锁屏壁纸等元素会随之发生变化。</p>
</blockquote>
<blockquote>
<p>（1）请使用抽象工厂模式设计系统</p>
</blockquote>
<blockquote>
<p>（2）为系统增加一种新的主题，并实现</p>
</blockquote>
<blockquote>
<p>（3）如果当系统主题发生变化的时候通讯录风格也发生变化，在这种情况之下上面设计的系统将如何变化？</p>
</blockquote>
<blockquote>
<p>（4）（2）和（3）的结论说明了什么？</p>
</blockquote>
<h2 id="实例类图"><a href="#实例类图" class="headerlink" title="实例类图"></a>实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117184331121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="实例实现代码"><a href="#实例实现代码" class="headerlink" title="实例实现代码"></a>实例实现代码</h2><blockquote>
<p>3.1抽象产品类ZC32Typeface（字体类）</p>
</blockquote>
<pre><code>    public interface ZC32Typeface {
        public void changeTypeface();
    }
</code></pre>
<blockquote>
<p>3.11具体产品类ZC32Typeface1（字体1类）</p>
</blockquote>
<pre><code>    public class ZC32Typeface1 implements ZC32Typeface{
        public void changeTypeface() {
            System.out.println("字体1已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.12具体产品类ZC32Typeface2（字体2类）</p>
</blockquote>
<pre><code>    public class ZC32Typeface2 implements ZC32Typeface{
    public void changeTypeface() {
        System.out.println("字体2已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.2抽象产品类ZC32Wallpaper（壁纸类）</p>
</blockquote>
<pre><code>public interface ZC32Wallpaper {
    public void changeWallpaper();
}
</code></pre>
<blockquote>
<p>3.21具体产品类ZC32Wallpaper1（壁纸1类）</p>
</blockquote>
<pre><code>    public class ZC32Wallpaper1 implements ZC32Wallpaper{
    public void changeWallpaper() {
        System.out.println("壁纸1已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.22具体产品类ZC32Wallpaper2（壁纸2类）</p>
</blockquote>
<pre><code>public class ZC32Wallpaper2 implements ZC32Wallpaper{
public void changeWallpaper() {
    System.out.println("壁纸2已应用！");
    }
}
</code></pre>
<blockquote>
<p>3.3抽象产品类ZC32LSWallpaper（锁屏壁纸类）</p>
</blockquote>
<pre><code>    public interface ZC32LSWallpaper {
        public void changeLSWallpaper();
    }
</code></pre>
<blockquote>
<p>3.31具体产品类ZC32LSWallpaper1（锁屏壁纸1类）</p>
</blockquote>
<pre><code>    public class ZC32Wallpaper1  implements ZC32LSWallpaper{
        public void changeLSWallpaper() {
            System.out.println("锁屏壁纸1已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.32具体产品类ZC32LSWallpaper2（锁屏壁纸2类）</p>
</blockquote>
<pre><code>    public class ZC32Wallpaper2 {
        public void changeLSWallpaper()  implements ZC32LSWallpaper{
            System.out.println("锁屏壁纸2已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.4抽象产品类ZC32Lcon（图标类）</p>
</blockquote>
<pre><code>    public interface ZC32Lcon {
        public void changeLcon();
    }
</code></pre>
<blockquote>
<p>3.41抽具体产品类ZC32Lcon1（图标1类）</p>
</blockquote>
<pre><code>    public class ZC32Lcon1 {
        public void changeLcon() implements ZC32Lcon{
            System.out.println("图标1已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.42抽具体产品类ZC32Lcon2（图标2类）</p>
</blockquote>
<pre><code>    public class ZC32Lcon2 {
        public void changeLcon() implements ZC32Lcon{
            System.out.println("图标2已应用！");
        }
    }
</code></pre>
<blockquote>
<p>3.5抽象工厂类ZC32TitleFactory（主题工厂类）</p>
</blockquote>
<pre><code>    public interface ZC32TitleFactory {
        public ZC32Typeface produceTypeface();
        public ZC32Wallpaper produceWallpaper();
        public ZC32LSWallpaper produceLSWallpaper();
        public ZC32Lcon produceLcon();
    }
</code></pre>
<blockquote>
<p>3.51具体工厂类ZC32TitleFactory1（主题工厂1类）</p>
</blockquote>
<pre><code>    public class ZC32TitleFactory1 implements ZC32TitleFactory{
        public ZC32Typeface produceTypeface() {
            return new  ZC32Typeface1();
        }
        public ZC32Wallpaper produceWallpaper() {
            return  new ZC32Wallpaper1();
        }
        public ZC32LSWallpaper produceLSWallpaper() {
            return  new ZC32LSWallpaper1();
        }
        public ZC32Lcon produceLcon() {
            return new ZC32Lcon1();
        }
    }
</code></pre>
<blockquote>
<p>3.52具体工厂类ZC32TitleFactory2（主题工厂2类）</p>
</blockquote>
<pre><code>    public class ZC32TitleFactory2 implements ZC32TitleFactory{
        public ZC32Typeface produceTypeface() {
            return new  ZC32Typeface2();
        }
        public ZC32Wallpaper produceWallpaper() {
            return  new ZC32Wallpaper2();
        }
        public ZC32LSWallpaper produceLSWallpaper() {
            return  new ZC32LSWallpaper2();
        }
        public ZC32Lcon produceLcon() {
            return new ZC32Lcon2();
        }
    }
</code></pre>
<blockquote>
<p>3.6客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String args[]) {
            try
            {
                ZC32TitleFactory factory;
                ZC32Typeface typeface;
                ZC32Wallpaper wallpaper;
                ZC32LSWallpaper lSWallpaper;
                ZC32Lcon lcon ;
                factory=(ZC32TitleFactory)XMLUtil.getBean();
                typeface=factory.produceTypeface();
                typeface.changeTypeface();
                wallpaper=factory.produceWallpaper();
                wallpaper.changeWallpaper();
                lSWallpaper=factory.produceLSWallpaper();
                lSWallpaper.changeLSWallpaper();
                lcon=factory.produceLcon();
                lcon.changeLcon();
            }
            catch(Exception e) {
                System.out.print("sssss");
                System.out.print(e.getMessage());
            }
        }
    }
</code></pre>
<h2 id="4、辅助代码"><a href="#4、辅助代码" class="headerlink" title="4、辅助代码"></a>4、辅助代码</h2><blockquote>
<p>4.1XML操作工具类XMLUtil</p>
</blockquote>
<pre><code>    import java.io.*;
    import javax.xml.parsers.*;
    import org.w3c.dom.*;
     
    public class XMLUtil {
        public static Object getBean() {
            try {
                //创建DOM文档对象
                DocumentBuilderFactory dFactory =DocumentBuilderFactory.newInstance();
                DocumentBuilder builder =dFactory.newDocumentBuilder();
                Document doc;
                doc=builder.parse(new File("config.xml"));
                
                NodeList nl=doc.getElementsByTagName("className");
                Node classNode=nl.item(0).getFirstChild();
                String cName=classNode.getNodeValue();
                
                Class c=Class.forName(cName);
                Object obj=c.newInstance();
                return obj;
            }
            catch(Exception e)
            {
                e.printStackTrace();
                return null;
            }
        }
    }    
</code></pre>
<blockquote>
<p>4.2配置文件config.xml</p>
</blockquote>
<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;config&gt;
        &lt;className&gt;ZC32SubMealBuilderB&lt;/className&gt;
    &lt;/config&gt;
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p>5.1（第一问）通过修改配置文件config.xml得到不同结果<br><img src="https://img-blog.csdnimg.cn/20201117190110149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20201117190137897.png"></p>
</blockquote>
<blockquote>
<p>5.2第二问）通过添加具体工厂3再修改配置文件config.xml得到结果具体工厂类ZC32TitleFactory3（主题工厂3类）</p>
</blockquote>
<pre><code>    public class ZC32TitleFactory3 implements ZC32TitleFactory{
        public ZC32Typeface produceTypeface() {
            return new  ZC32Typeface2();
        }
        public ZC32Wallpaper produceWallpaper() {
            return  new ZC32Wallpaper1();
        }
        public ZC32LSWallpaper produceLSWallpaper() {
            return  new ZC32LSWallpaper1();
        }
        public ZC32Lcon produceLcon() {
            return new ZC32Lcon2();
        }
    }
</code></pre>
<blockquote>
<p>5.3（第三问）在主题里建立一个通讯录的产品，然后加入一个新的工厂类-通讯录类即可，原有代码需要有较大的修改。</p>
</blockquote>
<blockquote>
<p>5.4（第四问） 在抽象工厂模式里，如果只是增加一个新的产品，比如改题目增加一个主题，只需要增加相应的具体工厂就行，再将配置文件里的具体工程类类名改成新增的工厂类类名，原有代码无需修改，但是要增加一种新的产品，即通讯录也随主题变化而变化，那么原有类名需要较大的修改，在抽象工厂里需要声明一个通讯录的方法，所有的具体工厂类都需要实现该方法，将导致系统不再符合“开放原则”。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式之克隆一个图形对象（圆形和矩形）</title>
    <url>/2020/11/19/design-pattern04/</url>
    <content><![CDATA[<h1 id="原型模式之克隆一个图形对象（圆形和矩形）"><a href="#原型模式之克隆一个图形对象（圆形和矩形）" class="headerlink" title="原型模式之克隆一个图形对象（圆形和矩形）"></a>原型模式之克隆一个图形对象（圆形和矩形）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 在运行期建立和删除原型。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p>
</blockquote>
<blockquote>
<p>**优点： ** 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong>  1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
</blockquote>
<blockquote>
<p><strong>注意事项：</strong> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>有一个画板,可以从中取得两种图形:圆形(circle)和矩形(rectangle),它们都属于原型(prototype),当客户需要画一个图形时便从画板中取一个图形,在这个问题中,原型模式的关键在于画板克隆一个图形对象,然后返回给客户。</p>
</blockquote>
<h2 id="实例类图"><a href="#实例类图" class="headerlink" title="实例类图"></a>实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117190857663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="实例实现代码"><a href="#实例实现代码" class="headerlink" title="实例实现代码"></a>实例实现代码</h2><blockquote>
<p>3.1抽象原型类ZC32Graph</p>
</blockquote>
<pre><code>    public interface ZC32Graph extends Cloneable{
        public Object clone();
        public String getName();
        public  void  draw();
    }
</code></pre>
<blockquote>
<p>3.11具体原型类ZC32Rectangle</p>
</blockquote>
<pre><code>    public class ZC32Rectangle implements ZC32Graph{
          public  Object clone(){
               Object clone= null ;
                try {
                   clone= (Object)super.clone();
               } catch (CloneNotSupportedException e){
                  
               }
                return  clone;
            }
             public  String getName(){
                return   "Rectangle" ;
            }
             public  void  draw(){
               System.out.println( "Draw a rectangle" );
             }
        }
</code></pre>
<blockquote>
<p>3.12具体原型类ZC32Circle</p>
</blockquote>
<pre><code>    public class ZC32Circle implements ZC32Graph{
        public  Object clone(){
               Object clone= null ;
                try {
                   clone= (Object)super.clone();
               } catch (CloneNotSupportedException e){
                  
               }
                return  clone;
            }
             public  String getName(){
                return   "circle" ;
            }
             public  void  draw(){
               System.out.println("Draw a circle");
            }
    }
</code></pre>
<blockquote>
<p>3.2原型管理器类ZC32Manager</p>
</blockquote>
<pre><code>    package yuanxingmoshi;
    import java.util.HashMap;
    import java.util.Hashtable;
     
    public class ZC32Manager {
          private  HashMap  ht =new  HashMap();
             public  ZC32Manager(){
                ht.put( "circle", new ZC32Circle());
                ht.put( "rectangle", new ZC32Rectangle());      
            }
             public  Object getClone(String key){
               Object obj =  ht.get(key);
                if (obj!= null ) return  ((ZC32Graph)obj).clone();
                return   null ;
    }}
</code></pre>
<blockquote>
<p>3.3客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public   static   void  main(String[] args){
            ZC32Manager ma =  new  ZC32Manager();
            
            ZC32Graph obj1=(ZC32Graph)ma.getClone( "circle" );
            obj1.draw();
                
                ZC32Graph obj2=(ZC32Graph)ma.getClone( "rectangle" );
                obj2.draw();
            }
    }
</code></pre>
<h2 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201117192154589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式之网站计算器</title>
    <url>/2020/11/20/design-pattern05/</url>
    <content><![CDATA[<h1 id="单例模式之网站计算器"><a href="#单例模式之网站计算器" class="headerlink" title="单例模式之网站计算器"></a>单例模式之网站计算器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
</blockquote>
<blockquote>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意：</p>
<p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  当您想控制实例数目，节省系统资源的时候。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  构造函数是私有的。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、一个班级只有一个班主任。<br>          2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>        3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>          2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>网站计算器是web应用程序的一项基本功能,用于统计使用网站的人数,可反应出网站的受欢迎程序,请使用单例模式设计计数器</p>
</blockquote>
<h2 id="实例类图"><a href="#实例类图" class="headerlink" title="实例类图"></a>实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117192449717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="实例实现代码"><a href="#实例实现代码" class="headerlink" title="实例实现代码"></a>实例实现代码</h2><blockquote>
<p>3.1单例类ZC32Singleton</p>
</blockquote>
<pre><code>public class ZC32Singleton {
    private static ZC32Singleton instance=null;
    private int count;
    private ZC32Singleton(){
        
    }
    public static ZC32Singleton getInstance(){
        if(instance==null){
            System.out.println("网站计算器已开启！！！");
            instance=new ZC32Singleton();
        }
        return instance;
    }
    public int getCount(){
        return count;
    }
    public void addOne(){
        this.count++;
        System.out.println("来访用户+1！目前访问次数为："+count);
    }
}
</code></pre>
<blockquote>
<p>3.2客户端测试类ZC32Client</p>
</blockquote>
<pre><code>public class ZC32Client {
    public static void main(String a[]) {
        ZC32Singleton zc1,zc2,zc3,zc4;
            zc1=ZC32Singleton.getInstance();
            zc1.addOne();
            zc2=ZC32Singleton.getInstance();
            zc2.addOne();
            zc3=ZC32Singleton.getInstance();
            zc3.addOne();
            zc4=ZC32Singleton.getInstance();
            zc4.addOne();
    }
}
 
</code></pre>
<h2 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020111719290169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式之消息发送</title>
    <url>/2020/11/21/design-pattern06/</url>
    <content><![CDATA[<h1 id="桥接模式之消息发送"><a href="#桥接模式之消息发送" class="headerlink" title="桥接模式之消息发送"></a>桥接模式之消息发送</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
</blockquote>
<blockquote>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
</blockquote>
<blockquote>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  实现系统可能有多个角度分类，每一种角度都可能变化。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  抽象类依赖实现类。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong>  1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong> 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>电子商务网站常有这样的功能：发送消息通知，比如订货发货通知等，从业务上看，消息分为普通消息、加急消息和特急消息多种不同的消息类型，其业务处理是不一样的，比如加急消息是在消息上添加加急标记，而特急消息是添加了加急标记外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内消息、手机短信消息、邮件等。请使用合适的设计模式进行设计，绘制所选择模式的结构图，并绘制该案例的类图，并编写代码实现并进行演示。</p>
</blockquote>
<h2 id="2、所用模式结构视图"><a href="#2、所用模式结构视图" class="headerlink" title="2、所用模式结构视图"></a>2、所用模式结构视图</h2><p><img src="https://img-blog.csdnimg.cn/20201117193217233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="3、实例类图"><a href="#3、实例类图" class="headerlink" title="3、实例类图"></a>3、实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117193315206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、实例实现代码"><a href="#4、实例实现代码" class="headerlink" title="4、实例实现代码"></a>4、实例实现代码</h2><blockquote>
<p>4.1实现类接口ZC32Type(消息类型类)</p>
</blockquote>
<pre><code>public interface ZC32Type {
    
    void besend(String MeansType,String counts);
}
</code></pre>
<blockquote>
<p>4.11具体实现类ZC32CommonNews(普通消息类)</p>
</blockquote>
<pre><code>public class ZC32CommonNews implements ZC32Type{
    public void besend(String MeansType,String counts) {
        System.out.println( MeansType+"普通消息"+counts+".");
    }
}
</code></pre>
<blockquote>
<p>4.12具体实现类ZC32UNews(加急消息类)</p>
</blockquote>
<pre><code>    public class ZC32UNews implements ZC32Type{
        public void besend(String MeansType,String counts) {
            System.out.println( MeansType+"加急消息"+counts+".");
        }
    }
</code></pre>
<blockquote>
<p>4.13具体实现类ZC32EuNews(特急消息类)</p>
</blockquote>
<pre><code>    public class ZC32EuNews implements ZC32Type{
        public void besend(String MeansType,String counts) {
            System.out.println( MeansType+"特急消息"+counts+".");
        }
    }
</code></pre>
<blockquote>
<p>4.2抽象类ZC32Means(发送消息手段类)</p>
</blockquote>
<pre><code>    public abstract class ZC32Means {
        protected ZC32Type type;
        public void setType(ZC32Type type) {
            this.type=type;
        }
        public abstract void send(String counts);
    }
</code></pre>
<blockquote>
<p>4.21扩充抽象类ZC32SystemNews(系统内消息类)</p>
</blockquote>
<pre><code>    public class ZC32SystemNews extends ZC32Means{
        public void send(String counts)
        {
            String MeansType="系统内消息";
            this.type.besend(MeansType, counts);
        }
    }
</code></pre>
<blockquote>
<p>4.22扩充抽象类ZC32PhoneNews(手机短信消息类)</p>
</blockquote>
<pre><code>    public class ZC32PhoneNews extends ZC32Means{
        public void send(String counts)
        {
            String MeansType="手机短信消息";
            this.type.besend(MeansType, counts);
        }
    }
</code></pre>
<blockquote>
<p>4.23扩充抽象类ZC32MailNews(邮件消息类)</p>
</blockquote>
<pre><code>    public class ZC32MailNews extends ZC32Means{
        public void send(String counts)
        {
            String MeansType="邮件消息";
            this.type.besend(MeansType, counts);
        }
     
    }
</code></pre>
<blockquote>
<p>4.3客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String args[]) {
            ZC32Type type1 =new ZC32EuNews();
            ZC32Means means1=new ZC32MailNews();
            means1.setType(type1);
            means1.send("一条");
        
            ZC32Type type2 =new ZC32UNews();
            ZC32Means means2=new ZC32PhoneNews();
            means2.setType(type2);
            means2.send("五条");
        
            ZC32Type type3 =new ZC32CommonNews();
            ZC32Means means3=new ZC32SystemNews();
            means3.setType(type3);
            means3.send("八条");    
        }
    }
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201117194048475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式之购物车商品推荐</title>
    <url>/2020/11/22/design-pattern07/</url>
    <content><![CDATA[<h1 id="适配器模式之购物车商品推荐"><a href="#适配器模式之购物车商品推荐" class="headerlink" title="适配器模式之购物车商品推荐"></a>适配器模式之购物车商品推荐</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 继承或依赖（推荐）。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  适配器继承或依赖已有的对象，实现想要的目标接口。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong>  1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong> 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>电子商务网站有购物车的功能，可以把挑选的东西加入购物车，可以把挑选的东西加入购物车、删除或者更改购买数量，并对多个商品进行一次性结算。为了实现订单功能，系统基于MVC模式，设计了一个下订单的页面index.jsp，商品信息管理类productioninfo，购物车信息管理类ShopCart。系统运行一段时间后，需求发生变化，不仅需要原有购物车的功能，还希望在客户下完订单后有一个相关商品的推荐功能，利用适配器模式进行设计，绘制选择模式的结构图，并绘制该案例的类图，并编写代码演示结果。</p>
</blockquote>
<h2 id="2、所用模式结构视图"><a href="#2、所用模式结构视图" class="headerlink" title="2、所用模式结构视图"></a>2、所用模式结构视图</h2><p><img src="https://img-blog.csdnimg.cn/20201117194326111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="3、实例类图"><a href="#3、实例类图" class="headerlink" title="3、实例类图"></a>3、实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117194411729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、实例实现代码"><a href="#4、实例实现代码" class="headerlink" title="4、实例实现代码"></a>4、实例实现代码</h2><blockquote>
<p>4.1目标抽象类ZC32Index（订单界面接口）</p>
</blockquote>
<pre><code>    public interface ZC32Index {
        public void productioninfo();
        public void shopCart();
     
    }
</code></pre>
<blockquote>
<p>4.2适配者类ZC32Function（ZC32Function类）</p>
</blockquote>
<pre><code>    public class ZC32Function {
        public void recommend() {
            System.out.println("开始推荐推荐相关商品！！！");
        }
        public void productioninfo() {
            System.out.println("商品信息进行管理！！！");
        }
        public void shopCart()
        {
            System.out.println("购物车商品进行编辑！！！");
        }
    }}
</code></pre>
<blockquote>
<p>4.3适配器类ZC32FunctionAdapter（ZC32FunctionAdapter类）</p>
</blockquote>
<pre><code>    public class ZC32FunctionAdapter extends ZC32Function implements ZC32Index{
        public void productioninfo()
        {
            System.out.println("商品信息管理类！！！");
            super.productioninfo();
            super.recommend();
        }
        public void shopCart()
        {
            System.out.println("购物车信息管理类！！！");
            super.shopCart();
            super.recommend();
        }
    }
</code></pre>
<blockquote>
<p>4.4客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String args[])
        {
            ZC32Index index=new ZC32FunctionAdapter();
            index.productioninfo();
            index.shopCart();
        }
     
    }
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201117194736302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式之相亲（男人的描述）</title>
    <url>/2020/11/23/design-pattern08/</url>
    <content><![CDATA[<h1 id="装饰者模式之相亲（男人的描述）"><a href="#装饰者模式之相亲（男人的描述）" class="headerlink" title="装饰者模式之相亲（男人的描述）"></a>装饰者模式之相亲（男人的描述）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
</blockquote>
<blockquote>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  在不想增加很多子类的情况下扩展类。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 将具体功能职责划分，同时继承装饰者模式。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  1、Component 类充当抽象角色，不应该具体实现。2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong>  装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</blockquote>
<blockquote>
<p><strong>缺点：</strong> 多层装饰比较复杂。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br><strong>注意事项：</strong> 可代替继承。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>这是一个关于相亲的故事。某家有女初长成，七大姑八大姨欲帮忙寻得佳婿，后在各种群、圈、网站，收集了各种男人的资料。这里需要一个应用生成收集过来的男人的描述，如：是否有车、是否有房、是否有存款、是否有好品质。然后这个应用了装饰者模式的应用诞生了，动态添加男人的描述，最后得到男人的综述。</p>
</blockquote>
<h2 id="2、所用模式结构视图"><a href="#2、所用模式结构视图" class="headerlink" title="2、所用模式结构视图"></a>2、所用模式结构视图</h2><p><img src="https://img-blog.csdnimg.cn/20201117195029895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="3、实例类图"><a href="#3、实例类图" class="headerlink" title="3、实例类图"></a>3、实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117195155656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、实例实现代码"><a href="#4、实例实现代码" class="headerlink" title="4、实例实现代码"></a>4、实例实现代码</h2><blockquote>
<p>4.1抽象构件类ZC32Man（男人）</p>
</blockquote>
<pre><code>    public interface ZC32Man {
        public void issingle();
    }
</code></pre>
<blockquote>
<p>4.2具体构件类ZC32Single（单身）</p>
</blockquote>
<pre><code>    public class ZC32Single implements ZC32Man{
        public void issingle() {
            System.out.println("该男子是适龄单身狗！！！");
        }
    }
</code></pre>
<blockquote>
<p>4.3抽象装饰类ZC32Describe（描述）</p>
</blockquote>
<pre><code>    public class ZC32Describe implements ZC32Man{
        private ZC32Man man;
        
        public void ishave(ZC32Man man) {
            this.man=man;
        }
        public void issingle() {
            man.issingle();
        }}
</code></pre>
<blockquote>
<p>4.31具体装饰类ZC32Car（有车类）</p>
</blockquote>
<pre><code>    public class ZC32Car extends ZC32Describe{
        public ZC32Car(ZC32Man man) {
            super();
            
        }
        public void ishave() {
            System.out.println("有车！！！");
        }
    }
</code></pre>
<blockquote>
<p>4.32具体装饰类ZC32Room（有房类）</p>
</blockquote>
<pre><code>    public class ZC32Room extends ZC32Describe{
        public ZC32Room(ZC32Man man) {
            super();
            
        }
        public void ishave() {
            System.out.println("有房！！！");
        }
    }
</code></pre>
<blockquote>
<p>4.33具体装饰类ZC32Money（有存款类）</p>
</blockquote>
<pre><code>    public class ZC32Money extends ZC32Describe{
        public ZC32Money(ZC32Man man) {
            super();
            
        }
        public void ishave() {
            System.out.println("有存款！！！");
        }
    }
</code></pre>
<blockquote>
<p>4.34具体装饰类ZC32Character（有品格类）</p>
</blockquote>
<pre><code>    public class ZC32Character extends ZC32Describe{
        public ZC32Character(ZC32Man man) {
            super();
        }
        public void ishave() {
            System.out.println("有存款！！！");
        }
    }
</code></pre>
<blockquote>
<p>4.4客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String args[]) {
            ZC32Man Bob;
            Bob =new ZC32Single();
            Bob.issingle();
            System.out.println("----------------------------");
            ZC32Car c=new ZC32Car(Bob);
            c.ishave();
            ZC32Room d=new ZC32Room(Bob);
            d.ishave();
            ZC32Money e=new ZC32Money(Bob);
            e.ishave();
            ZC32Character f=new ZC32Character(Bob);
            f.ishave();
        }
     
    }
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201117200201725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式之对购物网站</title>
    <url>/2020/11/23/design-pattern09/</url>
    <content><![CDATA[<h1 id="组合模式之对购物网站"><a href="#组合模式之对购物网站" class="headerlink" title="组合模式之对购物网站"></a>组合模式之对购物网站</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
</blockquote>
<blockquote>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 树枝和叶子实现统一接口，树枝内部组合该接口。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong>  1、高层模块调用简单。 2、节点自由增加。<br><strong>缺点：</strong> 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong> 定义时为具体类。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>用组合模式对购物网站的商品进管理，绘制选择模式的结构图，并绘制该案例的类图，并编写代码演示结果，运行结果样例显示如右图所示。<br><img src="https://img-blog.csdnimg.cn/20201117200403842.png"></p>
</blockquote>
<h2 id="2、所用模式结构视图"><a href="#2、所用模式结构视图" class="headerlink" title="2、所用模式结构视图"></a>2、所用模式结构视图</h2><p><img src="https://img-blog.csdnimg.cn/2020111720052754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="3、实例类图"><a href="#3、实例类图" class="headerlink" title="3、实例类图"></a>3、实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117200613180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、实例实现代码"><a href="#4、实例实现代码" class="headerlink" title="4、实例实现代码"></a>4、实例实现代码</h2><blockquote>
<p>4.1抽象构件类ZC32Clothing</p>
</blockquote>
<pre><code>    public abstract class ZC32Clothing {
        protected String name;
        public ZC32Clothing(String name) {
            this.name=name;
        }
        public abstract void add(ZC32Clothing c);
        public abstract void remove(ZC32Clothing c);
        public abstract void display(int depth);    
    }
</code></pre>
<blockquote>
<p>4.2容器构建类ZC32SexClothing（男女服装类）</p>
</blockquote>
<pre><code>    import java.util.ArrayList;
    import java.util.List;
     
    public class ZC32SexCloting extends ZC32Clothing {
        private List&lt;ZC32Clothing&gt; list=new ArrayList&lt;ZC32Clothing&gt;();
        public ZC32SexCloting(String name) {
            super(name);
             
        }
     
        public void add(ZC32Clothing c) {
                list.add(c);
        }
        public void remove(ZC32Clothing c) {
            list.remove(c);
     
        }
        public void display(int depth) {
            for(int i=1;i&lt;=depth;++i)System.out.print("-");
            System.out.println(name);
            for(ZC32Clothing c:list)c.display(depth+4);
        }
    }
</code></pre>
<blockquote>
<p>4.3叶子构建类ZC32Type（具体服装类）</p>
</blockquote>
<pre><code>    public class ZC32Type extends ZC32Clothing{
         
            public ZC32Type(String name) {
                super(name);
         
            }
            public void add(ZC32Clothing c) {
                System.out.println("不能添加");
                
            }
            public void remove(ZC32Clothing c) {
                System.out.println("不能删除");
                
            }
            public void display(int depth) {
                for(int i=1;i&lt;=depth;++i)System.out.print("-");
                System.out.println(name);
            }
        }
</code></pre>
<blockquote>
<p>4.4客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String[] args) {
            ZC32Clothing c=new ZC32SexCloting("服装");
            
            ZC32Clothing man=new ZC32SexCloting("男装");
            ZC32Clothing woman=new ZC32SexCloting("女装");
            
            ZC32Clothing man1=new ZC32Type("衬衣");
            ZC32Clothing man2=new ZC32Type("夹克");
            ZC32Clothing woman1=new ZC32Type("裙子");
            ZC32Clothing woman2=new ZC32Type("套装");
                    
            c.add(man);
            c.add(woman);
            
            man.add(man1);
            man.add(man2);
            
            woman.add(woman1);
            woman.add(woman2);
            
            c.display(1);
     
        }
     
    }
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201117200941451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式之网店模板</title>
    <url>/2020/11/25/design-pattern10/</url>
    <content><![CDATA[<h1 id="享元模式之网店模板"><a href="#享元模式之网店模板" class="headerlink" title="享元模式之网店模板"></a>享元模式之网店模板</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
</blockquote>
<blockquote>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>意图：</strong> 运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<blockquote>
<p><strong>主要解决：</strong> 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
</blockquote>
<blockquote>
<p><strong>何时使用：</strong>  1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
</blockquote>
<blockquote>
<p><strong>如何解决：</strong> 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
</blockquote>
<blockquote>
<p><strong>关键代码：</strong>  用 HashMap 存储这些对象。</p>
</blockquote>
<blockquote>
<p><strong>应用实例：</strong> 用 HashMap 存储这些对象。</p>
</blockquote>
<blockquote>
<p><strong>优点：</strong>  大大减少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong> 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
</blockquote>
<blockquote>
<p>**使用场景： ** 1、系统有大量相似对象。 2、需要缓冲池的场景。<br><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
</blockquote>
<h2 id="1、-实例概况"><a href="#1、-实例概况" class="headerlink" title="1、 实例概况"></a>1、 实例概况</h2><blockquote>
<p>在天猫商城里存在着成天上万的网店，但是天猫所提供的网站模板是一样的，存在许多天猫网店使用同一个网店模板的情况，如果每一个网店都用一个网店对象来表示，因为网店数量巨大，我们需求很多的网店对象来表示，但是，采用同一套网店模板的网店除了里面所展示的内容不一样或者使用权限不同以外，网店的风格样式几乎一致，除了一些定制化的功能，比如logo等，请使用享元模式来模拟此问题。</p>
</blockquote>
<h2 id="2、所用模式结构视图"><a href="#2、所用模式结构视图" class="headerlink" title="2、所用模式结构视图"></a>2、所用模式结构视图</h2><p><img src="https://img-blog.csdnimg.cn/20201117201133101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="3、实例类图"><a href="#3、实例类图" class="headerlink" title="3、实例类图"></a>3、实例类图</h2><p><img src="https://img-blog.csdnimg.cn/20201117201210158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、实例实现代码"><a href="#4、实例实现代码" class="headerlink" title="4、实例实现代码"></a>4、实例实现代码</h2><blockquote>
<p>4.1抽象享元类ZC32OnlineShop（网店类）</p>
</blockquote>
<pre><code>    public abstract class ZC32OnlineShop {
        public abstract  void logo(ZC32Logo logo);
    }
</code></pre>
<blockquote>
<p>4.2具体享元类ZC32ZC32Style（风格样式类）</p>
</blockquote>
<pre><code>    public class ZC32Style extends ZC32OnlineShop {
        private String style;
        
        public ZC32Style(String style) {
            this.style = style;
        }
        public void logo(ZC32Logo logo) {
            System.out.println("网店风格:   " + style + "          logo:   "+logo.getLogo());
        }
    }
</code></pre>
<blockquote>
<p>4.3非共享具体享元类ZC32Logo（logo类）</p>
</blockquote>
<pre><code>    public class ZC32Logo  {
        private String logo;
     
        public ZC32Logo(String logo){
              this.logo=logo;
             }
       
         public String getLogo() {
             return logo;
    }}
</code></pre>
<blockquote>
<p>4.4享元工厂类ZC32OnlineShopFactory（网店模板工厂类）</p>
</blockquote>
<pre><code>    import java.util.HashMap;
     
    public class ZC32OnlineShopFactory {    
         private  HashMap&lt;String, ZC32OnlineShop&gt; shops=new HashMap&lt;String, ZC32OnlineShop&gt;();
      
          public ZC32OnlineShop GetStyle(String style){
              ZC32OnlineShop shop=shops.get(style);
             if(shop!=null){
                  return shop;
              }else{
                  shop=new ZC32Style(style);
                  shops.put(style, shop);
                  return shop;
              }
          }
       
          public int getWebSiteNum(){
              return shops.size();
          }
    }
</code></pre>
<blockquote>
<p>4.5客户端测试类ZC32Client</p>
</blockquote>
<pre><code>    public class ZC32Client {
        public static void main(String[] args){
            ZC32OnlineShopFactory shop=new ZC32OnlineShopFactory();
       
            ZC32OnlineShop ZC32OnlineShop1=shop.GetStyle("服装类网店");
            ZC32OnlineShop1.logo(new ZC32Logo("小明的服装"));
            ZC32OnlineShop ZC32OnlineShop2=shop.GetStyle("服装类网店");
            ZC32OnlineShop2.logo(new ZC32Logo("帅痞之家"));
            ZC32OnlineShop ZC32OnlineShop3=shop.GetStyle("服装类网店");
            ZC32OnlineShop3.logo(new ZC32Logo("男人的最爱"));
       
            ZC32OnlineShop ZC32OnlineShop4=shop.GetStyle("数码类网店");
            ZC32OnlineShop4.logo(new ZC32Logo("华为"));
            ZC32OnlineShop ZC32OnlineShop5=shop.GetStyle("数码类网店");
            ZC32OnlineShop5.logo(new ZC32Logo("小米"));
            ZC32OnlineShop ZC32OnlineShop6=shop.GetStyle("数码类网店");
            ZC32OnlineShop6.logo(new ZC32Logo("OPPO"));
       
            System.out.println("得到所有网店总数为："+shop.getWebSiteNum());
    }}
</code></pre>
<h2 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h2><p><img src="https://img-blog.csdnimg.cn/20201117201603697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODk4MjIy,size_16,color_FFFFFF,t_70">    </p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 和 LinkedList 的区别是什么？</title>
    <url>/2021/10/07/java01/</url>
    <content><![CDATA[<h1 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h1><h2 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h2><p><strong>ArrayList的优点如下：</strong><br>   ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了RandomAccess 接口，因此查找的时候非常快。<br>   ArrayList 在顺序添加一个元素的时候非常方便。</p>
<p><strong>ArrayList 的缺点如下：</strong><br>   删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。<br>   插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<h2 id="ArrayList-和-LinkedList-的区别是什么？-1"><a href="#ArrayList-和-LinkedList-的区别是什么？-1" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h2><p><strong>数据结构实现：</strong> ArrayList 是动态数组的数据结构实现，而LinkedList 是双向链表的数据结构实现。</p>
<p><strong>随机访问效率：</strong> ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p><strong>增加和删除效率：</strong> 在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
<p><strong>内存空间占用：</strong> LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
<p><strong>线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA集合框架</tag>
        <tag>JAVA面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次博客文章测试</title>
    <url>/2019/09/07/first/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><strong>This is my first time to use Markdown</strong><br><em>第一次用文本编辑器写Markdown文档</em><br><del>这只是万里长征第一步</del> </p>
<p><del>这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</del><br>但是，万事开头难 有了第一步，坚持下去，定有收获！</p>
]]></content>
  </entry>
  <entry>
    <title>Java的三大特性</title>
    <url>/2021/11/01/java00/</url>
    <content><![CDATA[<h1 id="Java的三大特性"><a href="#Java的三大特性" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h1><h2 id="Java的三大特性-1"><a href="#Java的三大特性-1" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h2><p><strong>封装:</strong> 隐藏内部功能的具体实现，只保留和外部交流数据的接口，将变化隔离，便于使用，提高复用性和安全性。例：汽车与发动机，不必知道发动机的实现原理，只需使用汽车给予的接口，插入钥匙。</p>
<p><strong>继承:</strong> 一个对象可以从它的父类继承所有的通用的属性和方法，并在无需重新编写原来的类的情况下对这些功能进行扩展；最大的好处是实现代码的高效重用。</p>
<ul>
<li>关于继承如下3点请记住：<br>　　１.子类拥有父类非 private 的属性和方法。<br>　　２.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>　　３.子类可以用自己的方式实现父类的方法。</li>
</ul>
<p><strong>多态:</strong> 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>  Java实现多态有三个必要条件：<em>继承、重写、向上转型</em>。</p>
<p><strong>1.继承：</strong>在多态中必须存在有继承关系的子类和父类。</p>
<p><strong>2.重写：</strong>子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p><strong>3.向上转型：</strong>在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手 四次挥手</title>
    <url>/2022/03/21/java04/</url>
    <content><![CDATA[<h1 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a>什么是三次握手？</h1><pre><code>    1.进行三次握手，首先向服务器发送一个syn报文，其中syn=1，seq number=1022(随机)；
    2.服务器接收到syn报文，根据syn=1判断客户端请求建立连接，并返回一个syn报文，为第一次握手，
其中ack number=1023(客户端seq number+1)，seq number=2032(随机)，syn=1，ack=1；
    3.客户端根据服务器的syn报文，确认其ack number是否与上一次发送的seq number+1相等，且ack=1，确认正确，则回应一个ack报文，为第二次握手，
即ack number=2033(服务器seq number+1)，ack=1；
    4.服务器根据接收到的ack报文，确认ack number是否与上一次发送的seq number+1相等，并且ack=1，确认正确，则建立连接，
进入Established状态，为第三次握手。
</code></pre>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手"></a>什么是四次挥手</h2><blockquote>
<p>由于TCP连接是全双工的,断开一个TCP连接,需要客户端与服务器发送四个包来确认连接的断开</p>
</blockquote>
<h2 id="简述四次挥手的过程"><a href="#简述四次挥手的过程" class="headerlink" title="简述四次挥手的过程:"></a>简述四次挥手的过程:</h2><pre><code>    因为TCP是全双工的,因此,每个方向都要单独关闭
    当一方完成数据发送任务后,发送一个FIN来终止这一方向的连接,收到一个FIN只是意味着
    一方向不会再收到数据了,但是这个TCP连接上仍然能够发送数据,直到这一方也发送了FIN.
    首先进行关闭的一方执行主动关闭,另一方执行被动关闭.第一个关闭的最后等待2MSL
</code></pre>
<h2 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h2><blockquote>
<p>Client将FIN置为1,序号seq=M,发送给Server,进入FIN_WAIT_1状态</p>
</blockquote>
<h2 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h2><blockquote>
<p>Server收到后,将ACK置为1,ack=M+1,响应给Client,进入CLOSE_WAIT状态，Client收到响应后,进入FIN_WAIT_2状态</p>
</blockquote>
<h2 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h2><blockquote>
<p>Server在结束所有数据传输后,将Fin置为1,seq=N+1,发送给Client,进入LAST_ACK状态</p>
</blockquote>
<h2 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h2><blockquote>
<p>Client收到后,将ACK置为1,ack=N+1,响应给Server,进入TIME_WAIT状态,等待2MSL后,进入CLOSED状态，Server收到后,进入CLOSED状态</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>== 和 equals 的区别是什么</title>
    <url>/2021/12/21/java02/</url>
    <content><![CDATA[<h1 id="x3D-x3D-和-equals-的区别是什么？"><a href="#x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h1><p>**== : ** 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p><strong>equals() :</strong> 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<blockquote>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</blockquote>
<blockquote>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
</blockquote>
<pre><code>public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
</code></pre>
<blockquote>
<p><em>说明：</em><br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2022/01/02/java03/</url>
    <content><![CDATA[<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><p><strong>多线程:</strong> 多线程是指程序中包含多个执行流，即在-个程序中可以同时运行多个不同的线程来执行不同的任务。</p>
<p><strong>多线程的好处:</strong> 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p>
<p><strong>多线程的劣势：</strong> 1.线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；2.多线程需要协调和管理，所以需要 CPU 时间跟踪线程；3.线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</p>
<h1 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h1><h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><p> <strong>进程：</strong>是程序的一次执行，是具有一定独立功能的程序关于某个数据集合上的一次运动活动，是操作系统资源分配和调度的最小单位。</p>
<p><strong>线程：</strong>是操作系统能够进行运算调度的最小单位，它包含在进程之中，是进程中实际运作单位。</p>
<p><strong>两者关系：</strong> 进程是指程序执行时的一个实例，线程是进程的一个实体；线程必定也只属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；多个线程可共享数据。</p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p><strong>进程：</strong><br>    - 拥有独立的堆栈空间和数据段，系统开销大<br>    - 由于进程之间是独立的特点 使得进程的安全性比较高 有独立的地址空间 一个进程崩溃 不影响其他进程<br>    - 进程的通信机制相对复杂 譬如管道、信号、消息队列、套接字等<br><strong>线程：</strong><br>    - 线程拥有独立的堆栈空间 但是共享数据段，它们彼此之间使用相同的地址空间，比进程开销小<br>    - 线程是一个进程中不同的执行路径 一个线程的死亡就等于整个进程的死亡。<br>    - 通信相对方便</p>
<p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>
<p><strong>根本区别：</strong> 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>资源开销：</strong> 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>包含关系：</strong> 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>内存分配：</strong> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>
<p><strong>影响关系：</strong> 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p><strong>执行过程：</strong> 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><ul>
<li><p>继承 Thread 类；</p>
<pre><code>  public class MyThread extends Thread {
  @Override
  public void run() {
      System.out.println(Thread.currentThread().getName() + " run()方法正在执行...");
  }
</code></pre>
</li>
<li><p>实现 Runnable 接口；</p>
<pre><code>  public class MyRunnable implements Runnable {
  @Override
  public void run() {
      System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
  }
</code></pre>
</li>
<li><p>实现 Callable 接口；</p>
<pre><code>      public class MyCallable implements Callable&lt;Integer&gt; {
      @Override
      public Integer call() {
          System.out.println(Thread.currentThread().getName() + " call()方法执行中...");
          return 1;
      }
</code></pre>
</li>
<li><p>使用匿名内部类方式。</p>
<pre><code>  public class CreateRunnable {
  public static void main(String[] args) {
  //创建多线程创建开始
      Thread thread = new Thread(new Runnable() {
          public void run() {
              for (int i = 0; i &lt; 10; i++) 
              {
                  System.out.println("i:" + i);
              }
          }
      });
  thread.start();
  }
  }
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务与脏读幻读</title>
    <url>/2021/10/08/mysql01/</url>
    <content><![CDATA[<h1 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h1><p><strong>说一下什么是数据库事务</strong><br>   事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p><strong>事物的四大特性(ACID)介绍一下?</strong><br><em>原子性：</em> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br><em>一致性：</em> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br><em>隔离性：</em> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br><em>持久性：</em> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
<p><strong>什么是脏读？幻读？不可重复读？</strong><br><strong>脏读(Drity Read)：</strong> 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。<br><strong>不可重复读(Non-repeatable read):</strong> 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<br><strong>幻读(Phantom Read):</strong> 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p><strong>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</strong><br>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<p><strong>SQL 标准定义了四个隔离级别：</strong><br><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>mysql数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池</title>
    <url>/2022/01/21/java05/</url>
    <content><![CDATA[<h1 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h1><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li>
</ul>
<h1 id="线程池作用？"><a href="#线程池作用？" class="headerlink" title="线程池作用？"></a>线程池作用？</h1><ul>
<li><p>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</p>
</li>
<li><p>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
<li><p>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Redis</title>
    <url>/2022/04/02/redis01/</url>
    <content><![CDATA[<h1 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h1><blockquote>
<p>Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis的数据都基于缓存的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</p>
</blockquote>
<h1 id="Redis有哪些优缺点？"><a href="#Redis有哪些优缺点？" class="headerlink" title="Redis有哪些优缺点？"></a>Redis有哪些优缺点？</h1><p><strong>优点</strong></p>
<blockquote>
<ol>
<li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ol>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<ol>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ol>
</blockquote>
<p><strong>Redis有哪些数据类型</strong></p>
<blockquote>
<p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p>
</blockquote>
<p><strong>Redis持久化</strong><br>什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p><strong>Redis 的持久化机制是什么？各自的优缺点？</strong><br>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p><strong>RDB：是Redis DataBase缩写快照</strong></p>
<blockquote>
<p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n?x-oss-process=image/format,png"></p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<p>1、只有一个文件 dump.rdb，方便持久化。<br>2、容灾性好，一个文件可以保存到安全的磁盘。<br>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能<br>4.相对于数据集大时，比 AOF 的启动效率更高。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)<br>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</p>
</blockquote>
<p><strong>AOF：持久化：</strong></p>
<blockquote>
<p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n?x-oss-process=image/format,png"></p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。<br>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。<br>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。<br>2、数据集大的时候，比 rdb 启动效率低。</p>
</blockquote>
<p><strong>俩种持久化的优缺点是什么？</strong></p>
<blockquote>
<ol>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ol>
</blockquote>
<p><strong>缓存雪崩</strong><br><em>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</em></p>
<p><em>解决方案</em></p>
<blockquote>
<p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。<br>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p>
</blockquote>
<p><strong>缓存穿透</strong><br><em>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</em></p>
<p><em>解决方案</em></p>
<blockquote>
<p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击<br>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</p>
</blockquote>
<p><strong>缓存击穿</strong><br><em>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</em></p>
<p><em>解决方案</em></p>
<blockquote>
<p>设置热点数据永远不过期。<br>加互斥锁，互斥锁</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>李跳跳</title>
    <url>/2020/04/03/ruan-jian-00/</url>
    <content><![CDATA[<h1 id="什么是李跳跳？"><a href="#什么是李跳跳？" class="headerlink" title="什么是李跳跳？"></a>什么是李跳跳？</h1><p>李跳跳是安卓神器，一个能帮助你自动跳过手机软件启动页广告的APP.<br><a href="https://wwe.lanzouw.com/b01v0g3wj?w1" title="点这里下载APP吧，密码1233。">点这里下载APP吧，密码1233。</a></p>
]]></content>
      <categories>
        <category>安卓APP</category>
      </categories>
      <tags>
        <tag>安卓APP</tag>
      </tags>
  </entry>
</search>
