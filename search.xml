<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一次博客文章测试</title>
    <url>/2019/09/07/first/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><strong>This is my first time to use Markdown</strong><br><em>第一次用文本编辑器写Markdown文档</em><br><del>这只是万里长征第一步</del> </p>
<p><del>这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</del><br>但是，万事开头难 有了第一步，坚持下去，定有收获！</p>
]]></content>
  </entry>
  <entry>
    <title>== 和 equals 的区别是什么</title>
    <url>/2021/12/21/java02/</url>
    <content><![CDATA[<h1 id="x3D-x3D-和-equals-的区别是什么？"><a href="#x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h1><p>**== : ** 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p><strong>equals() :</strong> 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<blockquote>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</blockquote>
<blockquote>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
</blockquote>
<pre><code>public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
</code></pre>
<blockquote>
<p><em>说明：</em><br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
        <tag>JAVA面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2022/01/02/java03/</url>
    <content><![CDATA[<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><p><strong>多线程:</strong> 多线程是指程序中包含多个执行流，即在-个程序中可以同时运行多个不同的线程来执行不同的任务。</p>
<p><strong>多线程的好处:</strong> 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p>
<p><strong>多线程的劣势：</strong> 1.线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；2.多线程需要协调和管理，所以需要 CPU 时间跟踪线程；3.线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</p>
<h1 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h1><h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h2><p> <strong>进程：</strong>是程序的一次执行，是具有一定独立功能的程序关于某个数据集合上的一次运动活动，是操作系统资源分配和调度的最小单位。</p>
<p><strong>线程：</strong>是操作系统能够进行运算调度的最小单位，它包含在进程之中，是进程中实际运作单位。</p>
<p><strong>两者关系：</strong> 进程是指程序执行时的一个实例，线程是进程的一个实体；线程必定也只属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；多个线程可共享数据。</p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p><strong>进程：</strong><br>    - 拥有独立的堆栈空间和数据段，系统开销大<br>    - 由于进程之间是独立的特点 使得进程的安全性比较高 有独立的地址空间 一个进程崩溃 不影响其他进程<br>    - 进程的通信机制相对复杂 譬如管道、信号、消息队列、套接字等<br><strong>线程：</strong><br>    - 线程拥有独立的堆栈空间 但是共享数据段，它们彼此之间使用相同的地址空间，比进程开销小<br>    - 线程是一个进程中不同的执行路径 一个线程的死亡就等于整个进程的死亡。<br>    - 通信相对方便</p>
<p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>
<p><strong>根本区别：</strong> 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>资源开销：</strong> 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>包含关系：</strong> 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>内存分配：</strong> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>
<p><strong>影响关系：</strong> 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p><strong>执行过程：</strong> 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><ul>
<li><p>继承 Thread 类；</p>
<pre><code>  public class MyThread extends Thread {
  @Override
  public void run() {
      System.out.println(Thread.currentThread().getName() + " run()方法正在执行...");
  }
</code></pre>
</li>
<li><p>实现 Runnable 接口；</p>
<pre><code>  public class MyRunnable implements Runnable {
  @Override
  public void run() {
      System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
  }
</code></pre>
</li>
<li><p>实现 Callable 接口；</p>
<pre><code>      public class MyCallable implements Callable&lt;Integer&gt; {
      @Override
      public Integer call() {
          System.out.println(Thread.currentThread().getName() + " call()方法执行中...");
          return 1;
      }
</code></pre>
</li>
<li><p>使用匿名内部类方式。</p>
<pre><code>  public class CreateRunnable {
  public static void main(String[] args) {
  //创建多线程创建开始
      Thread thread = new Thread(new Runnable() {
          public void run() {
              for (int i = 0; i &lt; 10; i++) 
              {
                  System.out.println("i:" + i);
              }
          }
      });
  thread.start();
  }
  }
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的三大特性</title>
    <url>/2021/11/01/java00/</url>
    <content><![CDATA[<h1 id="Java的三大特性"><a href="#Java的三大特性" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h1><h2 id="Java的三大特性-1"><a href="#Java的三大特性-1" class="headerlink" title="Java的三大特性"></a>Java的三大特性</h2><p><strong>封装:</strong> 隐藏内部功能的具体实现，只保留和外部交流数据的接口，将变化隔离，便于使用，提高复用性和安全性。例：汽车与发动机，不必知道发动机的实现原理，只需使用汽车给予的接口，插入钥匙。</p>
<p><strong>继承:</strong> 一个对象可以从它的父类继承所有的通用的属性和方法，并在无需重新编写原来的类的情况下对这些功能进行扩展；最大的好处是实现代码的高效重用。</p>
<ul>
<li>关于继承如下3点请记住：<br>　　１.子类拥有父类非 private 的属性和方法。<br>　　２.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>　　３.子类可以用自己的方式实现父类的方法。</li>
</ul>
<p><strong>多态:</strong> 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>  Java实现多态有三个必要条件：<em>继承、重写、向上转型</em>。</p>
<p><strong>1.继承：</strong>在多态中必须存在有继承关系的子类和父类。</p>
<p><strong>2.重写：</strong>子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p><strong>3.向上转型：</strong>在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p><strong>重载：</strong>发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
        <tag>JAVA面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池</title>
    <url>/2022/01/21/java05/</url>
    <content><![CDATA[<h1 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h1><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li>
</ul>
<h1 id="线程池作用？"><a href="#线程池作用？" class="headerlink" title="线程池作用？"></a>线程池作用？</h1><ul>
<li><p>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</p>
</li>
<li><p>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
<li><p>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 和 LinkedList 的区别是什么？</title>
    <url>/2021/10/07/java01/</url>
    <content><![CDATA[<h1 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h1><h2 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h2><p><strong>ArrayList的优点如下：</strong><br>   ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了RandomAccess 接口，因此查找的时候非常快。<br>   ArrayList 在顺序添加一个元素的时候非常方便。</p>
<p><strong>ArrayList 的缺点如下：</strong><br>   删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。<br>   插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<h2 id="ArrayList-和-LinkedList-的区别是什么？-1"><a href="#ArrayList-和-LinkedList-的区别是什么？-1" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h2><p><strong>数据结构实现：</strong> ArrayList 是动态数组的数据结构实现，而LinkedList 是双向链表的数据结构实现。</p>
<p><strong>随机访问效率：</strong> ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p><strong>增加和删除效率：</strong> 在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
<p><strong>内存空间占用：</strong> LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
<p><strong>线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务与脏读幻读</title>
    <url>/2021/10/08/mysql01/</url>
    <content><![CDATA[<h1 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h1><p><strong>说一下什么是数据库事务</strong><br>   事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p><strong>事物的四大特性(ACID)介绍一下?</strong><br><em>原子性：</em> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br><em>一致性：</em> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br><em>隔离性：</em> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br><em>持久性：</em> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
<p><strong>什么是脏读？幻读？不可重复读？</strong><br><strong>脏读(Drity Read)：</strong> 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。<br><strong>不可重复读(Non-repeatable read):</strong> 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<br><strong>幻读(Phantom Read):</strong> 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p><strong>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</strong><br>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<p><strong>SQL 标准定义了四个隔离级别：</strong><br><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>mysql数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手 四次挥手</title>
    <url>/2022/03/21/java04/</url>
    <content><![CDATA[<h1 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a>什么是三次握手？</h1><pre><code>    1.进行三次握手，首先向服务器发送一个syn报文，其中syn=1，seq number=1022(随机)；
    2.服务器接收到syn报文，根据syn=1判断客户端请求建立连接，并返回一个syn报文，为第一次握手，
其中ack number=1023(客户端seq number+1)，seq number=2032(随机)，syn=1，ack=1；
    3.客户端根据服务器的syn报文，确认其ack number是否与上一次发送的seq number+1相等，且ack=1，确认正确，则回应一个ack报文，为第二次握手，
即ack number=2033(服务器seq number+1)，ack=1；
    4.服务器根据接收到的ack报文，确认ack number是否与上一次发送的seq number+1相等，并且ack=1，确认正确，则建立连接，
进入Established状态，为第三次握手。
</code></pre>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手"></a>什么是四次挥手</h2><blockquote>
<p>由于TCP连接是全双工的,断开一个TCP连接,需要客户端与服务器发送四个包来确认连接的断开</p>
</blockquote>
<h2 id="简述四次挥手的过程"><a href="#简述四次挥手的过程" class="headerlink" title="简述四次挥手的过程:"></a>简述四次挥手的过程:</h2><pre><code>    因为TCP是全双工的,因此,每个方向都要单独关闭
    当一方完成数据发送任务后,发送一个FIN来终止这一方向的连接,收到一个FIN只是意味着
    一方向不会再收到数据了,但是这个TCP连接上仍然能够发送数据,直到这一方也发送了FIN.
    首先进行关闭的一方执行主动关闭,另一方执行被动关闭.第一个关闭的最后等待2MSL
</code></pre>
<h2 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h2><blockquote>
<p>Client将FIN置为1,序号seq=M,发送给Server,进入FIN_WAIT_1状态</p>
</blockquote>
<h2 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h2><blockquote>
<p>Server收到后,将ACK置为1,ack=M+1,响应给Client,进入CLOSE_WAIT状态，Client收到响应后,进入FIN_WAIT_2状态</p>
</blockquote>
<h2 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h2><blockquote>
<p>Server在结束所有数据传输后,将Fin置为1,seq=N+1,发送给Client,进入LAST_ACK状态</p>
</blockquote>
<h2 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h2><blockquote>
<p>Client收到后,将ACK置为1,ack=N+1,响应给Server,进入TIME_WAIT状态,等待2MSL后,进入CLOSED状态，Server收到后,进入CLOSED状态</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>梦奇</title>
    <url>/2022/04/02/meng-qi/</url>
    <content><![CDATA[<h1 id="什么是梦奇？"><a href="#什么是梦奇？" class="headerlink" title="什么是梦奇？"></a>什么是梦奇？</h1><p>梦奇是一个人，一个女孩子</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA面试题</tag>
        <tag>JAVA多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>李跳跳</title>
    <url>/2022/04/03/ruan-jian-00/</url>
    <content><![CDATA[<h1 id="什么是李跳跳？"><a href="#什么是李跳跳？" class="headerlink" title="什么是李跳跳？"></a>什么是李跳跳？</h1><p>李跳跳是安卓神器，一个能帮助你自动跳过手机软件启动页广告的APP.<br><a href="https://wwe.lanzouw.com/b01v0g3wj?w1" title="点这里下载APP吧，密码1233。">点这里下载APP吧，密码1233。</a></p>
]]></content>
      <categories>
        <category>安卓APP</category>
      </categories>
      <tags>
        <tag>安卓APP</tag>
      </tags>
  </entry>
</search>
